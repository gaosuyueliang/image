# 栈溢出（缓冲区溢出）

> 在了解栈溢出之前，我们需要了解几个概念：堆栈是什么以及汇编语言中的call指令的特点。

## 堆栈：

​		堆栈是一个特定的存储器或寄存器，其本质就是存储数据的内存。在实际应用中，堆栈会用于**存储临时变**量、**函数调用**、中断切换时**保存和恢复现场数据**。

![堆栈示意图](https://gitee.com/ah-pull-the-crotch/image/raw/master/%E5%A0%86%E6%A0%88%E7%A4%BA%E6%84%8F%E5%9B%BE.png)

​		如图所示，堆栈就是内存中的某一片区域，每一个堆栈的内存单元都有唯一一个物理地址，且内存单元的大小都统一是4个字节大小。

> 并不是esp和ebp之间的范围才是堆栈，整个区域都是堆栈，而esp（栈顶）和esp（栈底）的作用只是定位数据的位置。

​		栈溢出就是发生在这样一个存储区域中。在了解了发生溢出的环境之后，了解溢出就相当于了解了一半了，另一半原因与使用的call指令有关。

## Call指令：

​		call指令通常用于调用函数。用下面的例子理解。

*cpu执行的程序*

![call指令](https://gitee.com/ah-pull-the-crotch/image/raw/master/call%E6%8C%87%E4%BB%A4.png)

*对应的堆栈变化*

![call指令对应的堆栈变化](https://gitee.com/ah-pull-the-crotch/image/raw/master/call%E6%8C%87%E4%BB%A4%E5%AF%B9%E5%BA%94%E7%9A%84%E5%A0%86%E6%A0%88%E5%8F%98%E5%8C%96.png)

> call指令在调执行时，先看call指令的长度和call所在的物理地址，这样才能计算出call指令的下一个指令地址。并且会把下一个指令地址存储到堆栈中。

​		之后cpu就会在堆栈中开辟出一段存储空间用于调用函数、存储临时变量。这里不细说。

*函数调用时对堆栈的使用*（图中用CCCCCCCC填充的内存单元就是缓冲区，存放局部变量就是在这里）

![调用函数堆栈图](https://gitee.com/ah-pull-the-crotch/image/raw/master/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%A0%86%E6%A0%88%E5%9B%BE.png)

*函数调用完后对堆栈的处理*

![函数结束调用堆栈图](https://gitee.com/ah-pull-the-crotch/image/raw/master/%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%BB%93%E6%9D%9F%E5%A0%86%E6%A0%88%E5%9B%BE.png)

> 小结：
>
> 1、函数调用完之后数据还是存储在堆栈当中，没有被真的删除，变化的只是esp和ebp指向的位置。
>
> 2、函数调用完之后，esp和ebp的位置会回到函数开始前的位置。**也就是说我们的esp指向的位置是我们在调用函数执行call指令时所存在堆栈中的返回地址。**

​		讲完call的特点和函数调用，现在就把栈溢出所需了解的知识点都知道了。

## 栈溢出（缓冲区溢出）：

​		在了解完堆栈结构和call指令后，我们可以清楚的知道如果我们在调用一个函数时传入一个数据，如果这个数据大小超过我们所分配的缓冲区大小，那么就会造成缓冲区溢出。

**堆栈图可以帮助我们更好的理解溢出的发生。**

![缓冲区溢出](https://gitee.com/ah-pull-the-crotch/image/raw/master/%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA.png)

​		图中左边的堆栈可以看到给我们所分配的存储局部变量的位置是[ebp-14h]至[ebp-4]这个范围中，但是当我们输入的数据超过这个范围之后，多余的数据就被安排到了[ebp-adr]这个堆栈单元中了。[ebp-adr]这个单元中存放的是我们的返回地址（call语句的下一条语句的地址）。

**缓冲区溢出的危害**

​		缓冲区溢出最基本的影响就是会造成系统报错，更大的危害是利用缓冲区溢出执行非程序本身的操作。

> 通过修改存在堆栈中的返回地址，可以跳转到我们想要执行的程序的物理地址。我们也可以计算好堆栈的空间，然后输入一串我们编写好的具有特殊功能的Shellcode，通过返回地址调整esp指向位置去执行我们编写的shellcode。

**缓冲区的利用方法**

- 普通的数据传入：通过传入大量的数据造成溢出。（就像上面的图）
- 数组越界：通过往超过数组空间大小的位置传入数据，可以指定修改堆栈中的数据。

```c
#include "stdafx.h"//版本：vc 6.0

void HelloWorld(){
	printf("HelloWorld");
	getchar();
}

void Fun(){
	int arr[5]={1,2,3,4,5};
	arr[6]=(int)HelloWorld;
}

int main(int argc, char* argv[])
{
	Fun();
	return 0;
}
```

​		这串代码就是用到了数组越界的方法。我们声明的数组大小为五，所以在堆栈中分配的五个堆栈内存单元，但是我们向下标为六的数组空间中存入我们Hello World函数的地址，这就造成了越界。

![数组越界](https://gitee.com/ah-pull-the-crotch/image/raw/master/%E6%95%B0%E7%BB%84%E8%B6%8A%E7%95%8C.png)

​		当程序开始开始通过返回地址返回时，就会跳转到Hello World函数处，而Hello World函数并没有返回到主函数的返回地址，所以就会造成报错。

**防止缓冲区溢出的方法---GS**

![GS机制](https://gitee.com/ah-pull-the-crotch/image/raw/master/GS%E6%9C%BA%E5%88%B6.png)

​		防止缓冲区溢出和数组越界的方法还有很多，以上也仅是缓冲区溢出的基本知识。